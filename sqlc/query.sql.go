// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.16.0
// source: query.sql

package sqlc

import (
	"context"
	"database/sql"
	"time"
)

const createEpisode = `-- name: CreateEpisode :one
INSERT INTO episodes (name, number_series, number_overall, release_date, description, body, transcript_url, podcast_id,
                      series_id)
VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9)
RETURNING id, name, number_series, number_overall, release_date, description, body, transcript_url, podcast_id, series_id, last_updated, fts_doc_en
`

type CreateEpisodeParams struct {
	Name          string    `json:"name"`
	NumberSeries  int32     `json:"number_series"`
	NumberOverall int32     `json:"number_overall"`
	ReleaseDate   time.Time `json:"release_date"`
	Description   string    `json:"description"`
	Body          string    `json:"body"`
	TranscriptUrl string    `json:"transcript_url"`
	PodcastID     int32     `json:"podcast_id"`
	SeriesID      int32     `json:"series_id"`
}

func (q *Queries) CreateEpisode(ctx context.Context, arg *CreateEpisodeParams) (*Episode, error) {
	row := q.db.QueryRowContext(ctx, createEpisode,
		arg.Name,
		arg.NumberSeries,
		arg.NumberOverall,
		arg.ReleaseDate,
		arg.Description,
		arg.Body,
		arg.TranscriptUrl,
		arg.PodcastID,
		arg.SeriesID,
	)
	var i Episode
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.NumberSeries,
		&i.NumberOverall,
		&i.ReleaseDate,
		&i.Description,
		&i.Body,
		&i.TranscriptUrl,
		&i.PodcastID,
		&i.SeriesID,
		&i.LastUpdated,
		&i.FtsDocEn,
	)
	return &i, err
}

const createPodcast = `-- name: CreatePodcast :one
INSERT INTO podcasts (name)
VALUES ($1)
RETURNING id, name, last_updated
`

func (q *Queries) CreatePodcast(ctx context.Context, name string) (*Podcast, error) {
	row := q.db.QueryRowContext(ctx, createPodcast, name)
	var i Podcast
	err := row.Scan(&i.ID, &i.Name, &i.LastUpdated)
	return &i, err
}

const createSeries = `-- name: CreateSeries :one
INSERT INTO series (name, podcast_id)
VALUES ($1, $2)
RETURNING id, name, podcast_id, last_updated
`

type CreateSeriesParams struct {
	Name      string `json:"name"`
	PodcastID int32  `json:"podcast_id"`
}

func (q *Queries) CreateSeries(ctx context.Context, arg *CreateSeriesParams) (*Series, error) {
	row := q.db.QueryRowContext(ctx, createSeries, arg.Name, arg.PodcastID)
	var i Series
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.PodcastID,
		&i.LastUpdated,
	)
	return &i, err
}

const deleteEpisode = `-- name: DeleteEpisode :exec
DELETE
FROM episodes
WHERE id = $1
`

func (q *Queries) DeleteEpisode(ctx context.Context, id int32) error {
	_, err := q.db.ExecContext(ctx, deleteEpisode, id)
	return err
}

const deletePodcast = `-- name: DeletePodcast :exec
DELETE
FROM podcasts
WHERE id = $1
`

func (q *Queries) DeletePodcast(ctx context.Context, id int32) error {
	_, err := q.db.ExecContext(ctx, deletePodcast, id)
	return err
}

const deleteSeries = `-- name: DeleteSeries :exec
DELETE
FROM series
WHERE id = $1
`

func (q *Queries) DeleteSeries(ctx context.Context, id int32) error {
	_, err := q.db.ExecContext(ctx, deleteSeries, id)
	return err
}

const getEpisode = `-- name: GetEpisode :one
SELECT id, name, number_series, number_overall, release_date, description, body, transcript_url, podcast_id, series_id, last_updated, fts_doc_en
FROM episodes
WHERE id = $1
LIMIT 1
`

func (q *Queries) GetEpisode(ctx context.Context, id int32) (*Episode, error) {
	row := q.db.QueryRowContext(ctx, getEpisode, id)
	var i Episode
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.NumberSeries,
		&i.NumberOverall,
		&i.ReleaseDate,
		&i.Description,
		&i.Body,
		&i.TranscriptUrl,
		&i.PodcastID,
		&i.SeriesID,
		&i.LastUpdated,
		&i.FtsDocEn,
	)
	return &i, err
}

const getPodcast = `-- name: GetPodcast :one
SELECT id, name, last_updated
FROM podcasts
WHERE id = $1
LIMIT 1
`

func (q *Queries) GetPodcast(ctx context.Context, id int32) (*Podcast, error) {
	row := q.db.QueryRowContext(ctx, getPodcast, id)
	var i Podcast
	err := row.Scan(&i.ID, &i.Name, &i.LastUpdated)
	return &i, err
}

const getSeries = `-- name: GetSeries :one
SELECT id, name, podcast_id, last_updated
FROM series
WHERE id = $1
LIMIT 1
`

func (q *Queries) GetSeries(ctx context.Context, id int32) (*Series, error) {
	row := q.db.QueryRowContext(ctx, getSeries, id)
	var i Series
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.PodcastID,
		&i.LastUpdated,
	)
	return &i, err
}

const listEpisodes = `-- name: ListEpisodes :many
SELECT id, name, number_series, number_overall, release_date, description, body, transcript_url, podcast_id, series_id, last_updated, fts_doc_en
FROM episodes
ORDER BY name
`

func (q *Queries) ListEpisodes(ctx context.Context) ([]*Episode, error) {
	rows, err := q.db.QueryContext(ctx, listEpisodes)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*Episode{}
	for rows.Next() {
		var i Episode
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.NumberSeries,
			&i.NumberOverall,
			&i.ReleaseDate,
			&i.Description,
			&i.Body,
			&i.TranscriptUrl,
			&i.PodcastID,
			&i.SeriesID,
			&i.LastUpdated,
			&i.FtsDocEn,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listPodcasts = `-- name: ListPodcasts :many
SELECT id, name, last_updated
FROM podcasts
ORDER BY name
`

func (q *Queries) ListPodcasts(ctx context.Context) ([]*Podcast, error) {
	rows, err := q.db.QueryContext(ctx, listPodcasts)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*Podcast{}
	for rows.Next() {
		var i Podcast
		if err := rows.Scan(&i.ID, &i.Name, &i.LastUpdated); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listSeries = `-- name: ListSeries :many
SELECT id, name, podcast_id, last_updated
FROM series
ORDER BY name
`

func (q *Queries) ListSeries(ctx context.Context) ([]*Series, error) {
	rows, err := q.db.QueryContext(ctx, listSeries)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*Series{}
	for rows.Next() {
		var i Series
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.PodcastID,
			&i.LastUpdated,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const searchEpisodes = `-- name: SearchEpisodes :many
SELECT id, name, number_series, number_overall, release_date, description, body, transcript_url, podcast_id, series_id, last_updated, fts_doc_en,
       ts_headline(body, websearch_to_tsquery($1))::text AS headline
FROM episodes
WHERE fts_doc_en @@ websearch_to_tsquery($1)
`

type SearchEpisodesRow struct {
	ID            int32       `json:"id"`
	Name          string      `json:"name"`
	NumberSeries  int32       `json:"number_series"`
	NumberOverall int32       `json:"number_overall"`
	ReleaseDate   time.Time   `json:"release_date"`
	Description   string      `json:"description"`
	Body          string      `json:"body"`
	TranscriptUrl string      `json:"transcript_url"`
	PodcastID     int32       `json:"podcast_id"`
	SeriesID      int32       `json:"series_id"`
	LastUpdated   time.Time   `json:"last_updated"`
	FtsDocEn      interface{} `json:"fts_doc_en"`
	Headline      string      `json:"headline"`
}

func (q *Queries) SearchEpisodes(ctx context.Context, websearchToTsquery string) ([]*SearchEpisodesRow, error) {
	rows, err := q.db.QueryContext(ctx, searchEpisodes, websearchToTsquery)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*SearchEpisodesRow{}
	for rows.Next() {
		var i SearchEpisodesRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.NumberSeries,
			&i.NumberOverall,
			&i.ReleaseDate,
			&i.Description,
			&i.Body,
			&i.TranscriptUrl,
			&i.PodcastID,
			&i.SeriesID,
			&i.LastUpdated,
			&i.FtsDocEn,
			&i.Headline,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateEpisode = `-- name: UpdateEpisode :one
UPDATE episodes
SET name           = COALESCE($1, name),
    number_series  = COALESCE($2, number_series),
    number_overall = COALESCE($3, number_overall),
    release_date   = COALESCE($4, release_date),
    description    = COALESCE($5, description),
    body           = COALESCE($6, body),
    transcript_url = COALESCE($7, transcript_url),
    podcast_id     = COALESCE($8, podcast_id),
    series_id      = COALESCE($9, series_id),
    last_updated   = NOW()
WHERE id = $10
RETURNING id, name, number_series, number_overall, release_date, description, body, transcript_url, podcast_id, series_id, last_updated, fts_doc_en
`

type UpdateEpisodeParams struct {
	Name          sql.NullString `json:"name"`
	NumberSeries  sql.NullInt32  `json:"number_series"`
	NumberOverall sql.NullInt32  `json:"number_overall"`
	ReleaseDate   sql.NullTime   `json:"release_date"`
	Description   sql.NullString `json:"description"`
	Body          sql.NullString `json:"body"`
	TranscriptUrl sql.NullString `json:"transcript_url"`
	PodcastID     sql.NullInt32  `json:"podcast_id"`
	SeriesID      sql.NullInt32  `json:"series_id"`
	ID            int32          `json:"id"`
}

func (q *Queries) UpdateEpisode(ctx context.Context, arg *UpdateEpisodeParams) (*Episode, error) {
	row := q.db.QueryRowContext(ctx, updateEpisode,
		arg.Name,
		arg.NumberSeries,
		arg.NumberOverall,
		arg.ReleaseDate,
		arg.Description,
		arg.Body,
		arg.TranscriptUrl,
		arg.PodcastID,
		arg.SeriesID,
		arg.ID,
	)
	var i Episode
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.NumberSeries,
		&i.NumberOverall,
		&i.ReleaseDate,
		&i.Description,
		&i.Body,
		&i.TranscriptUrl,
		&i.PodcastID,
		&i.SeriesID,
		&i.LastUpdated,
		&i.FtsDocEn,
	)
	return &i, err
}

const updatePodcast = `-- name: UpdatePodcast :one
UPDATE podcasts
SET name         = COALESCE($1, name),
    last_updated = NOW()
WHERE id = $2
RETURNING id, name, last_updated
`

type UpdatePodcastParams struct {
	Name sql.NullString `json:"name"`
	ID   int32          `json:"id"`
}

func (q *Queries) UpdatePodcast(ctx context.Context, arg *UpdatePodcastParams) (*Podcast, error) {
	row := q.db.QueryRowContext(ctx, updatePodcast, arg.Name, arg.ID)
	var i Podcast
	err := row.Scan(&i.ID, &i.Name, &i.LastUpdated)
	return &i, err
}

const updateSeries = `-- name: UpdateSeries :one
UPDATE series
SET name         = COALESCE($1, name),
    podcast_id   = COALESCE($2, podcast_id),
    last_updated = NOW()
WHERE id = $3
RETURNING id, name, podcast_id, last_updated
`

type UpdateSeriesParams struct {
	Name      sql.NullString `json:"name"`
	PodcastID sql.NullInt32  `json:"podcast_id"`
	ID        int32          `json:"id"`
}

func (q *Queries) UpdateSeries(ctx context.Context, arg *UpdateSeriesParams) (*Series, error) {
	row := q.db.QueryRowContext(ctx, updateSeries, arg.Name, arg.PodcastID, arg.ID)
	var i Series
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.PodcastID,
		&i.LastUpdated,
	)
	return &i, err
}
